// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'video.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$Video {
  dynamic get id => throw _privateConstructorUsedError;
  dynamic get rootUlid => throw _privateConstructorUsedError;
  dynamic get parentUlid => throw _privateConstructorUsedError;
  dynamic get grandparentUlid => throw _privateConstructorUsedError;
  bool get isSensitive => throw _privateConstructorUsedError;
  bool get isPrivate => throw _privateConstructorUsedError;
  bool get commentsEnabled => throw _privateConstructorUsedError;
  bool get downloadEnabled => throw _privateConstructorUsedError;
  bool get isTrolling => throw _privateConstructorUsedError;
  String? get body => throw _privateConstructorUsedError;
  dynamic get detectedLanguage => throw _privateConstructorUsedError;
  dynamic get username => throw _privateConstructorUsedError;
  User? get user => throw _privateConstructorUsedError;
  dynamic get postType => throw _privateConstructorUsedError;
  dynamic get title => throw _privateConstructorUsedError;
  List<SingleVideo> get videos => throw _privateConstructorUsedError;
  dynamic get videoProcessing => throw _privateConstructorUsedError;
  List<Tag>? get tags => throw _privateConstructorUsedError;
  bool? get edited => throw _privateConstructorUsedError;
  dynamic get userReaction => throw _privateConstructorUsedError;
  bool? get isRepost => throw _privateConstructorUsedError;
  bool? get isRepostWithComment => throw _privateConstructorUsedError;
  dynamic get embedUrl => throw _privateConstructorUsedError;
  dynamic get groupName => throw _privateConstructorUsedError;
  dynamic get groupId => throw _privateConstructorUsedError;
  dynamic get support => throw _privateConstructorUsedError;
  DateTime? get createdAt => throw _privateConstructorUsedError;
  DateTime? get updatedAt => throw _privateConstructorUsedError;
  bool? get isDeleted => throw _privateConstructorUsedError;
  dynamic get isHidden => throw _privateConstructorUsedError;
  bool? get isProcessing => throw _privateConstructorUsedError;
  UserEngagement? get userEngagement => throw _privateConstructorUsedError;
  PostEngagement? get postEngagement => throw _privateConstructorUsedError;

  /// Create a copy of Video
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $VideoCopyWith<Video> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VideoCopyWith<$Res> {
  factory $VideoCopyWith(Video value, $Res Function(Video) then) =
      _$VideoCopyWithImpl<$Res, Video>;
  @useResult
  $Res call(
      {dynamic id,
      dynamic rootUlid,
      dynamic parentUlid,
      dynamic grandparentUlid,
      bool isSensitive,
      bool isPrivate,
      bool commentsEnabled,
      bool downloadEnabled,
      bool isTrolling,
      String? body,
      dynamic detectedLanguage,
      dynamic username,
      User? user,
      dynamic postType,
      dynamic title,
      List<SingleVideo> videos,
      dynamic videoProcessing,
      List<Tag>? tags,
      bool? edited,
      dynamic userReaction,
      bool? isRepost,
      bool? isRepostWithComment,
      dynamic embedUrl,
      dynamic groupName,
      dynamic groupId,
      dynamic support,
      DateTime? createdAt,
      DateTime? updatedAt,
      bool? isDeleted,
      dynamic isHidden,
      bool? isProcessing,
      UserEngagement? userEngagement,
      PostEngagement? postEngagement});

  $UserCopyWith<$Res>? get user;
  $UserEngagementCopyWith<$Res>? get userEngagement;
  $PostEngagementCopyWith<$Res>? get postEngagement;
}

/// @nodoc
class _$VideoCopyWithImpl<$Res, $Val extends Video>
    implements $VideoCopyWith<$Res> {
  _$VideoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Video
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? rootUlid = freezed,
    Object? parentUlid = freezed,
    Object? grandparentUlid = freezed,
    Object? isSensitive = null,
    Object? isPrivate = null,
    Object? commentsEnabled = null,
    Object? downloadEnabled = null,
    Object? isTrolling = null,
    Object? body = freezed,
    Object? detectedLanguage = freezed,
    Object? username = freezed,
    Object? user = freezed,
    Object? postType = freezed,
    Object? title = freezed,
    Object? videos = null,
    Object? videoProcessing = freezed,
    Object? tags = freezed,
    Object? edited = freezed,
    Object? userReaction = freezed,
    Object? isRepost = freezed,
    Object? isRepostWithComment = freezed,
    Object? embedUrl = freezed,
    Object? groupName = freezed,
    Object? groupId = freezed,
    Object? support = freezed,
    Object? createdAt = freezed,
    Object? updatedAt = freezed,
    Object? isDeleted = freezed,
    Object? isHidden = freezed,
    Object? isProcessing = freezed,
    Object? userEngagement = freezed,
    Object? postEngagement = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as dynamic,
      rootUlid: freezed == rootUlid
          ? _value.rootUlid
          : rootUlid // ignore: cast_nullable_to_non_nullable
              as dynamic,
      parentUlid: freezed == parentUlid
          ? _value.parentUlid
          : parentUlid // ignore: cast_nullable_to_non_nullable
              as dynamic,
      grandparentUlid: freezed == grandparentUlid
          ? _value.grandparentUlid
          : grandparentUlid // ignore: cast_nullable_to_non_nullable
              as dynamic,
      isSensitive: null == isSensitive
          ? _value.isSensitive
          : isSensitive // ignore: cast_nullable_to_non_nullable
              as bool,
      isPrivate: null == isPrivate
          ? _value.isPrivate
          : isPrivate // ignore: cast_nullable_to_non_nullable
              as bool,
      commentsEnabled: null == commentsEnabled
          ? _value.commentsEnabled
          : commentsEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      downloadEnabled: null == downloadEnabled
          ? _value.downloadEnabled
          : downloadEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      isTrolling: null == isTrolling
          ? _value.isTrolling
          : isTrolling // ignore: cast_nullable_to_non_nullable
              as bool,
      body: freezed == body
          ? _value.body
          : body // ignore: cast_nullable_to_non_nullable
              as String?,
      detectedLanguage: freezed == detectedLanguage
          ? _value.detectedLanguage
          : detectedLanguage // ignore: cast_nullable_to_non_nullable
              as dynamic,
      username: freezed == username
          ? _value.username
          : username // ignore: cast_nullable_to_non_nullable
              as dynamic,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User?,
      postType: freezed == postType
          ? _value.postType
          : postType // ignore: cast_nullable_to_non_nullable
              as dynamic,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as dynamic,
      videos: null == videos
          ? _value.videos
          : videos // ignore: cast_nullable_to_non_nullable
              as List<SingleVideo>,
      videoProcessing: freezed == videoProcessing
          ? _value.videoProcessing
          : videoProcessing // ignore: cast_nullable_to_non_nullable
              as dynamic,
      tags: freezed == tags
          ? _value.tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<Tag>?,
      edited: freezed == edited
          ? _value.edited
          : edited // ignore: cast_nullable_to_non_nullable
              as bool?,
      userReaction: freezed == userReaction
          ? _value.userReaction
          : userReaction // ignore: cast_nullable_to_non_nullable
              as dynamic,
      isRepost: freezed == isRepost
          ? _value.isRepost
          : isRepost // ignore: cast_nullable_to_non_nullable
              as bool?,
      isRepostWithComment: freezed == isRepostWithComment
          ? _value.isRepostWithComment
          : isRepostWithComment // ignore: cast_nullable_to_non_nullable
              as bool?,
      embedUrl: freezed == embedUrl
          ? _value.embedUrl
          : embedUrl // ignore: cast_nullable_to_non_nullable
              as dynamic,
      groupName: freezed == groupName
          ? _value.groupName
          : groupName // ignore: cast_nullable_to_non_nullable
              as dynamic,
      groupId: freezed == groupId
          ? _value.groupId
          : groupId // ignore: cast_nullable_to_non_nullable
              as dynamic,
      support: freezed == support
          ? _value.support
          : support // ignore: cast_nullable_to_non_nullable
              as dynamic,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      isDeleted: freezed == isDeleted
          ? _value.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      isHidden: freezed == isHidden
          ? _value.isHidden
          : isHidden // ignore: cast_nullable_to_non_nullable
              as dynamic,
      isProcessing: freezed == isProcessing
          ? _value.isProcessing
          : isProcessing // ignore: cast_nullable_to_non_nullable
              as bool?,
      userEngagement: freezed == userEngagement
          ? _value.userEngagement
          : userEngagement // ignore: cast_nullable_to_non_nullable
              as UserEngagement?,
      postEngagement: freezed == postEngagement
          ? _value.postEngagement
          : postEngagement // ignore: cast_nullable_to_non_nullable
              as PostEngagement?,
    ) as $Val);
  }

  /// Create a copy of Video
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res>? get user {
    if (_value.user == null) {
      return null;
    }

    return $UserCopyWith<$Res>(_value.user!, (value) {
      return _then(_value.copyWith(user: value) as $Val);
    });
  }

  /// Create a copy of Video
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserEngagementCopyWith<$Res>? get userEngagement {
    if (_value.userEngagement == null) {
      return null;
    }

    return $UserEngagementCopyWith<$Res>(_value.userEngagement!, (value) {
      return _then(_value.copyWith(userEngagement: value) as $Val);
    });
  }

  /// Create a copy of Video
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $PostEngagementCopyWith<$Res>? get postEngagement {
    if (_value.postEngagement == null) {
      return null;
    }

    return $PostEngagementCopyWith<$Res>(_value.postEngagement!, (value) {
      return _then(_value.copyWith(postEngagement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$VideoImplCopyWith<$Res> implements $VideoCopyWith<$Res> {
  factory _$$VideoImplCopyWith(
          _$VideoImpl value, $Res Function(_$VideoImpl) then) =
      __$$VideoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {dynamic id,
      dynamic rootUlid,
      dynamic parentUlid,
      dynamic grandparentUlid,
      bool isSensitive,
      bool isPrivate,
      bool commentsEnabled,
      bool downloadEnabled,
      bool isTrolling,
      String? body,
      dynamic detectedLanguage,
      dynamic username,
      User? user,
      dynamic postType,
      dynamic title,
      List<SingleVideo> videos,
      dynamic videoProcessing,
      List<Tag>? tags,
      bool? edited,
      dynamic userReaction,
      bool? isRepost,
      bool? isRepostWithComment,
      dynamic embedUrl,
      dynamic groupName,
      dynamic groupId,
      dynamic support,
      DateTime? createdAt,
      DateTime? updatedAt,
      bool? isDeleted,
      dynamic isHidden,
      bool? isProcessing,
      UserEngagement? userEngagement,
      PostEngagement? postEngagement});

  @override
  $UserCopyWith<$Res>? get user;
  @override
  $UserEngagementCopyWith<$Res>? get userEngagement;
  @override
  $PostEngagementCopyWith<$Res>? get postEngagement;
}

/// @nodoc
class __$$VideoImplCopyWithImpl<$Res>
    extends _$VideoCopyWithImpl<$Res, _$VideoImpl>
    implements _$$VideoImplCopyWith<$Res> {
  __$$VideoImplCopyWithImpl(
      _$VideoImpl _value, $Res Function(_$VideoImpl) _then)
      : super(_value, _then);

  /// Create a copy of Video
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? rootUlid = freezed,
    Object? parentUlid = freezed,
    Object? grandparentUlid = freezed,
    Object? isSensitive = null,
    Object? isPrivate = null,
    Object? commentsEnabled = null,
    Object? downloadEnabled = null,
    Object? isTrolling = null,
    Object? body = freezed,
    Object? detectedLanguage = freezed,
    Object? username = freezed,
    Object? user = freezed,
    Object? postType = freezed,
    Object? title = freezed,
    Object? videos = null,
    Object? videoProcessing = freezed,
    Object? tags = freezed,
    Object? edited = freezed,
    Object? userReaction = freezed,
    Object? isRepost = freezed,
    Object? isRepostWithComment = freezed,
    Object? embedUrl = freezed,
    Object? groupName = freezed,
    Object? groupId = freezed,
    Object? support = freezed,
    Object? createdAt = freezed,
    Object? updatedAt = freezed,
    Object? isDeleted = freezed,
    Object? isHidden = freezed,
    Object? isProcessing = freezed,
    Object? userEngagement = freezed,
    Object? postEngagement = freezed,
  }) {
    return _then(_$VideoImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as dynamic,
      rootUlid: freezed == rootUlid
          ? _value.rootUlid
          : rootUlid // ignore: cast_nullable_to_non_nullable
              as dynamic,
      parentUlid: freezed == parentUlid
          ? _value.parentUlid
          : parentUlid // ignore: cast_nullable_to_non_nullable
              as dynamic,
      grandparentUlid: freezed == grandparentUlid
          ? _value.grandparentUlid
          : grandparentUlid // ignore: cast_nullable_to_non_nullable
              as dynamic,
      isSensitive: null == isSensitive
          ? _value.isSensitive
          : isSensitive // ignore: cast_nullable_to_non_nullable
              as bool,
      isPrivate: null == isPrivate
          ? _value.isPrivate
          : isPrivate // ignore: cast_nullable_to_non_nullable
              as bool,
      commentsEnabled: null == commentsEnabled
          ? _value.commentsEnabled
          : commentsEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      downloadEnabled: null == downloadEnabled
          ? _value.downloadEnabled
          : downloadEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      isTrolling: null == isTrolling
          ? _value.isTrolling
          : isTrolling // ignore: cast_nullable_to_non_nullable
              as bool,
      body: freezed == body
          ? _value.body
          : body // ignore: cast_nullable_to_non_nullable
              as String?,
      detectedLanguage: freezed == detectedLanguage
          ? _value.detectedLanguage
          : detectedLanguage // ignore: cast_nullable_to_non_nullable
              as dynamic,
      username: freezed == username
          ? _value.username
          : username // ignore: cast_nullable_to_non_nullable
              as dynamic,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User?,
      postType: freezed == postType
          ? _value.postType
          : postType // ignore: cast_nullable_to_non_nullable
              as dynamic,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as dynamic,
      videos: null == videos
          ? _value._videos
          : videos // ignore: cast_nullable_to_non_nullable
              as List<SingleVideo>,
      videoProcessing: freezed == videoProcessing
          ? _value.videoProcessing
          : videoProcessing // ignore: cast_nullable_to_non_nullable
              as dynamic,
      tags: freezed == tags
          ? _value._tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<Tag>?,
      edited: freezed == edited
          ? _value.edited
          : edited // ignore: cast_nullable_to_non_nullable
              as bool?,
      userReaction: freezed == userReaction
          ? _value.userReaction
          : userReaction // ignore: cast_nullable_to_non_nullable
              as dynamic,
      isRepost: freezed == isRepost
          ? _value.isRepost
          : isRepost // ignore: cast_nullable_to_non_nullable
              as bool?,
      isRepostWithComment: freezed == isRepostWithComment
          ? _value.isRepostWithComment
          : isRepostWithComment // ignore: cast_nullable_to_non_nullable
              as bool?,
      embedUrl: freezed == embedUrl
          ? _value.embedUrl
          : embedUrl // ignore: cast_nullable_to_non_nullable
              as dynamic,
      groupName: freezed == groupName
          ? _value.groupName
          : groupName // ignore: cast_nullable_to_non_nullable
              as dynamic,
      groupId: freezed == groupId
          ? _value.groupId
          : groupId // ignore: cast_nullable_to_non_nullable
              as dynamic,
      support: freezed == support
          ? _value.support
          : support // ignore: cast_nullable_to_non_nullable
              as dynamic,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      isDeleted: freezed == isDeleted
          ? _value.isDeleted
          : isDeleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      isHidden: freezed == isHidden
          ? _value.isHidden
          : isHidden // ignore: cast_nullable_to_non_nullable
              as dynamic,
      isProcessing: freezed == isProcessing
          ? _value.isProcessing
          : isProcessing // ignore: cast_nullable_to_non_nullable
              as bool?,
      userEngagement: freezed == userEngagement
          ? _value.userEngagement
          : userEngagement // ignore: cast_nullable_to_non_nullable
              as UserEngagement?,
      postEngagement: freezed == postEngagement
          ? _value.postEngagement
          : postEngagement // ignore: cast_nullable_to_non_nullable
              as PostEngagement?,
    ));
  }
}

/// @nodoc

class _$VideoImpl implements _Video {
  const _$VideoImpl(
      {required this.id,
      required this.rootUlid,
      required this.parentUlid,
      required this.grandparentUlid,
      required this.isSensitive,
      required this.isPrivate,
      required this.commentsEnabled,
      required this.downloadEnabled,
      required this.isTrolling,
      required this.body,
      required this.detectedLanguage,
      required this.username,
      required this.user,
      required this.postType,
      required this.title,
      required final List<SingleVideo> videos,
      required this.videoProcessing,
      required final List<Tag>? tags,
      required this.edited,
      required this.userReaction,
      required this.isRepost,
      required this.isRepostWithComment,
      required this.embedUrl,
      required this.groupName,
      required this.groupId,
      required this.support,
      required this.createdAt,
      required this.updatedAt,
      required this.isDeleted,
      required this.isHidden,
      required this.isProcessing,
      required this.userEngagement,
      required this.postEngagement})
      : _videos = videos,
        _tags = tags;

  @override
  final dynamic id;
  @override
  final dynamic rootUlid;
  @override
  final dynamic parentUlid;
  @override
  final dynamic grandparentUlid;
  @override
  final bool isSensitive;
  @override
  final bool isPrivate;
  @override
  final bool commentsEnabled;
  @override
  final bool downloadEnabled;
  @override
  final bool isTrolling;
  @override
  final String? body;
  @override
  final dynamic detectedLanguage;
  @override
  final dynamic username;
  @override
  final User? user;
  @override
  final dynamic postType;
  @override
  final dynamic title;
  final List<SingleVideo> _videos;
  @override
  List<SingleVideo> get videos {
    if (_videos is EqualUnmodifiableListView) return _videos;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_videos);
  }

  @override
  final dynamic videoProcessing;
  final List<Tag>? _tags;
  @override
  List<Tag>? get tags {
    final value = _tags;
    if (value == null) return null;
    if (_tags is EqualUnmodifiableListView) return _tags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final bool? edited;
  @override
  final dynamic userReaction;
  @override
  final bool? isRepost;
  @override
  final bool? isRepostWithComment;
  @override
  final dynamic embedUrl;
  @override
  final dynamic groupName;
  @override
  final dynamic groupId;
  @override
  final dynamic support;
  @override
  final DateTime? createdAt;
  @override
  final DateTime? updatedAt;
  @override
  final bool? isDeleted;
  @override
  final dynamic isHidden;
  @override
  final bool? isProcessing;
  @override
  final UserEngagement? userEngagement;
  @override
  final PostEngagement? postEngagement;

  @override
  String toString() {
    return 'Video(id: $id, rootUlid: $rootUlid, parentUlid: $parentUlid, grandparentUlid: $grandparentUlid, isSensitive: $isSensitive, isPrivate: $isPrivate, commentsEnabled: $commentsEnabled, downloadEnabled: $downloadEnabled, isTrolling: $isTrolling, body: $body, detectedLanguage: $detectedLanguage, username: $username, user: $user, postType: $postType, title: $title, videos: $videos, videoProcessing: $videoProcessing, tags: $tags, edited: $edited, userReaction: $userReaction, isRepost: $isRepost, isRepostWithComment: $isRepostWithComment, embedUrl: $embedUrl, groupName: $groupName, groupId: $groupId, support: $support, createdAt: $createdAt, updatedAt: $updatedAt, isDeleted: $isDeleted, isHidden: $isHidden, isProcessing: $isProcessing, userEngagement: $userEngagement, postEngagement: $postEngagement)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VideoImpl &&
            const DeepCollectionEquality().equals(other.id, id) &&
            const DeepCollectionEquality().equals(other.rootUlid, rootUlid) &&
            const DeepCollectionEquality()
                .equals(other.parentUlid, parentUlid) &&
            const DeepCollectionEquality()
                .equals(other.grandparentUlid, grandparentUlid) &&
            (identical(other.isSensitive, isSensitive) ||
                other.isSensitive == isSensitive) &&
            (identical(other.isPrivate, isPrivate) ||
                other.isPrivate == isPrivate) &&
            (identical(other.commentsEnabled, commentsEnabled) ||
                other.commentsEnabled == commentsEnabled) &&
            (identical(other.downloadEnabled, downloadEnabled) ||
                other.downloadEnabled == downloadEnabled) &&
            (identical(other.isTrolling, isTrolling) ||
                other.isTrolling == isTrolling) &&
            (identical(other.body, body) || other.body == body) &&
            const DeepCollectionEquality()
                .equals(other.detectedLanguage, detectedLanguage) &&
            const DeepCollectionEquality().equals(other.username, username) &&
            (identical(other.user, user) || other.user == user) &&
            const DeepCollectionEquality().equals(other.postType, postType) &&
            const DeepCollectionEquality().equals(other.title, title) &&
            const DeepCollectionEquality().equals(other._videos, _videos) &&
            const DeepCollectionEquality()
                .equals(other.videoProcessing, videoProcessing) &&
            const DeepCollectionEquality().equals(other._tags, _tags) &&
            (identical(other.edited, edited) || other.edited == edited) &&
            const DeepCollectionEquality()
                .equals(other.userReaction, userReaction) &&
            (identical(other.isRepost, isRepost) ||
                other.isRepost == isRepost) &&
            (identical(other.isRepostWithComment, isRepostWithComment) ||
                other.isRepostWithComment == isRepostWithComment) &&
            const DeepCollectionEquality().equals(other.embedUrl, embedUrl) &&
            const DeepCollectionEquality().equals(other.groupName, groupName) &&
            const DeepCollectionEquality().equals(other.groupId, groupId) &&
            const DeepCollectionEquality().equals(other.support, support) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt) &&
            (identical(other.isDeleted, isDeleted) ||
                other.isDeleted == isDeleted) &&
            const DeepCollectionEquality().equals(other.isHidden, isHidden) &&
            (identical(other.isProcessing, isProcessing) ||
                other.isProcessing == isProcessing) &&
            (identical(other.userEngagement, userEngagement) ||
                other.userEngagement == userEngagement) &&
            (identical(other.postEngagement, postEngagement) ||
                other.postEngagement == postEngagement));
  }

  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        const DeepCollectionEquality().hash(id),
        const DeepCollectionEquality().hash(rootUlid),
        const DeepCollectionEquality().hash(parentUlid),
        const DeepCollectionEquality().hash(grandparentUlid),
        isSensitive,
        isPrivate,
        commentsEnabled,
        downloadEnabled,
        isTrolling,
        body,
        const DeepCollectionEquality().hash(detectedLanguage),
        const DeepCollectionEquality().hash(username),
        user,
        const DeepCollectionEquality().hash(postType),
        const DeepCollectionEquality().hash(title),
        const DeepCollectionEquality().hash(_videos),
        const DeepCollectionEquality().hash(videoProcessing),
        const DeepCollectionEquality().hash(_tags),
        edited,
        const DeepCollectionEquality().hash(userReaction),
        isRepost,
        isRepostWithComment,
        const DeepCollectionEquality().hash(embedUrl),
        const DeepCollectionEquality().hash(groupName),
        const DeepCollectionEquality().hash(groupId),
        const DeepCollectionEquality().hash(support),
        createdAt,
        updatedAt,
        isDeleted,
        const DeepCollectionEquality().hash(isHidden),
        isProcessing,
        userEngagement,
        postEngagement
      ]);

  /// Create a copy of Video
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$VideoImplCopyWith<_$VideoImpl> get copyWith =>
      __$$VideoImplCopyWithImpl<_$VideoImpl>(this, _$identity);
}

abstract class _Video implements Video {
  const factory _Video(
      {required final dynamic id,
      required final dynamic rootUlid,
      required final dynamic parentUlid,
      required final dynamic grandparentUlid,
      required final bool isSensitive,
      required final bool isPrivate,
      required final bool commentsEnabled,
      required final bool downloadEnabled,
      required final bool isTrolling,
      required final String? body,
      required final dynamic detectedLanguage,
      required final dynamic username,
      required final User? user,
      required final dynamic postType,
      required final dynamic title,
      required final List<SingleVideo> videos,
      required final dynamic videoProcessing,
      required final List<Tag>? tags,
      required final bool? edited,
      required final dynamic userReaction,
      required final bool? isRepost,
      required final bool? isRepostWithComment,
      required final dynamic embedUrl,
      required final dynamic groupName,
      required final dynamic groupId,
      required final dynamic support,
      required final DateTime? createdAt,
      required final DateTime? updatedAt,
      required final bool? isDeleted,
      required final dynamic isHidden,
      required final bool? isProcessing,
      required final UserEngagement? userEngagement,
      required final PostEngagement? postEngagement}) = _$VideoImpl;

  @override
  dynamic get id;
  @override
  dynamic get rootUlid;
  @override
  dynamic get parentUlid;
  @override
  dynamic get grandparentUlid;
  @override
  bool get isSensitive;
  @override
  bool get isPrivate;
  @override
  bool get commentsEnabled;
  @override
  bool get downloadEnabled;
  @override
  bool get isTrolling;
  @override
  String? get body;
  @override
  dynamic get detectedLanguage;
  @override
  dynamic get username;
  @override
  User? get user;
  @override
  dynamic get postType;
  @override
  dynamic get title;
  @override
  List<SingleVideo> get videos;
  @override
  dynamic get videoProcessing;
  @override
  List<Tag>? get tags;
  @override
  bool? get edited;
  @override
  dynamic get userReaction;
  @override
  bool? get isRepost;
  @override
  bool? get isRepostWithComment;
  @override
  dynamic get embedUrl;
  @override
  dynamic get groupName;
  @override
  dynamic get groupId;
  @override
  dynamic get support;
  @override
  DateTime? get createdAt;
  @override
  DateTime? get updatedAt;
  @override
  bool? get isDeleted;
  @override
  dynamic get isHidden;
  @override
  bool? get isProcessing;
  @override
  UserEngagement? get userEngagement;
  @override
  PostEngagement? get postEngagement;

  /// Create a copy of Video
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$VideoImplCopyWith<_$VideoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$User {
  dynamic get userId => throw _privateConstructorUsedError;
  dynamic get avatar => throw _privateConstructorUsedError;
  DateTime get updatedAt => throw _privateConstructorUsedError;
  int get updatedAtEpoch => throw _privateConstructorUsedError;

  /// Create a copy of User
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $UserCopyWith<User> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserCopyWith<$Res> {
  factory $UserCopyWith(User value, $Res Function(User) then) =
      _$UserCopyWithImpl<$Res, User>;
  @useResult
  $Res call(
      {dynamic userId, dynamic avatar, DateTime updatedAt, int updatedAtEpoch});
}

/// @nodoc
class _$UserCopyWithImpl<$Res, $Val extends User>
    implements $UserCopyWith<$Res> {
  _$UserCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of User
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? userId = freezed,
    Object? avatar = freezed,
    Object? updatedAt = null,
    Object? updatedAtEpoch = null,
  }) {
    return _then(_value.copyWith(
      userId: freezed == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as dynamic,
      avatar: freezed == avatar
          ? _value.avatar
          : avatar // ignore: cast_nullable_to_non_nullable
              as dynamic,
      updatedAt: null == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updatedAtEpoch: null == updatedAtEpoch
          ? _value.updatedAtEpoch
          : updatedAtEpoch // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$UserImplCopyWith<$Res> implements $UserCopyWith<$Res> {
  factory _$$UserImplCopyWith(
          _$UserImpl value, $Res Function(_$UserImpl) then) =
      __$$UserImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {dynamic userId, dynamic avatar, DateTime updatedAt, int updatedAtEpoch});
}

/// @nodoc
class __$$UserImplCopyWithImpl<$Res>
    extends _$UserCopyWithImpl<$Res, _$UserImpl>
    implements _$$UserImplCopyWith<$Res> {
  __$$UserImplCopyWithImpl(_$UserImpl _value, $Res Function(_$UserImpl) _then)
      : super(_value, _then);

  /// Create a copy of User
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? userId = freezed,
    Object? avatar = freezed,
    Object? updatedAt = null,
    Object? updatedAtEpoch = null,
  }) {
    return _then(_$UserImpl(
      userId: freezed == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as dynamic,
      avatar: freezed == avatar
          ? _value.avatar
          : avatar // ignore: cast_nullable_to_non_nullable
              as dynamic,
      updatedAt: null == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updatedAtEpoch: null == updatedAtEpoch
          ? _value.updatedAtEpoch
          : updatedAtEpoch // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$UserImpl implements _User {
  const _$UserImpl(
      {required this.userId,
      required this.avatar,
      required this.updatedAt,
      required this.updatedAtEpoch});

  @override
  final dynamic userId;
  @override
  final dynamic avatar;
  @override
  final DateTime updatedAt;
  @override
  final int updatedAtEpoch;

  @override
  String toString() {
    return 'User(userId: $userId, avatar: $avatar, updatedAt: $updatedAt, updatedAtEpoch: $updatedAtEpoch)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserImpl &&
            const DeepCollectionEquality().equals(other.userId, userId) &&
            const DeepCollectionEquality().equals(other.avatar, avatar) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt) &&
            (identical(other.updatedAtEpoch, updatedAtEpoch) ||
                other.updatedAtEpoch == updatedAtEpoch));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(userId),
      const DeepCollectionEquality().hash(avatar),
      updatedAt,
      updatedAtEpoch);

  /// Create a copy of User
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UserImplCopyWith<_$UserImpl> get copyWith =>
      __$$UserImplCopyWithImpl<_$UserImpl>(this, _$identity);
}

abstract class _User implements User {
  const factory _User(
      {required final dynamic userId,
      required final dynamic avatar,
      required final DateTime updatedAt,
      required final int updatedAtEpoch}) = _$UserImpl;

  @override
  dynamic get userId;
  @override
  dynamic get avatar;
  @override
  DateTime get updatedAt;
  @override
  int get updatedAtEpoch;

  /// Create a copy of User
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UserImplCopyWith<_$UserImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Tag {
  dynamic get name => throw _privateConstructorUsedError;

  /// Create a copy of Tag
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $TagCopyWith<Tag> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TagCopyWith<$Res> {
  factory $TagCopyWith(Tag value, $Res Function(Tag) then) =
      _$TagCopyWithImpl<$Res, Tag>;
  @useResult
  $Res call({dynamic name});
}

/// @nodoc
class _$TagCopyWithImpl<$Res, $Val extends Tag> implements $TagCopyWith<$Res> {
  _$TagCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Tag
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TagImplCopyWith<$Res> implements $TagCopyWith<$Res> {
  factory _$$TagImplCopyWith(_$TagImpl value, $Res Function(_$TagImpl) then) =
      __$$TagImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({dynamic name});
}

/// @nodoc
class __$$TagImplCopyWithImpl<$Res> extends _$TagCopyWithImpl<$Res, _$TagImpl>
    implements _$$TagImplCopyWith<$Res> {
  __$$TagImplCopyWithImpl(_$TagImpl _value, $Res Function(_$TagImpl) _then)
      : super(_value, _then);

  /// Create a copy of Tag
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
  }) {
    return _then(_$TagImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc

class _$TagImpl implements _Tag {
  const _$TagImpl({required this.name});

  @override
  final dynamic name;

  @override
  String toString() {
    return 'Tag(name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TagImpl &&
            const DeepCollectionEquality().equals(other.name, name));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(name));

  /// Create a copy of Tag
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TagImplCopyWith<_$TagImpl> get copyWith =>
      __$$TagImplCopyWithImpl<_$TagImpl>(this, _$identity);
}

abstract class _Tag implements Tag {
  const factory _Tag({required final dynamic name}) = _$TagImpl;

  @override
  dynamic get name;

  /// Create a copy of Tag
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TagImplCopyWith<_$TagImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$UserEngagement {
  dynamic get hasReposted => throw _privateConstructorUsedError;
  dynamic get hasRepostedWithComment => throw _privateConstructorUsedError;
  dynamic get hasCommented => throw _privateConstructorUsedError;

  /// Create a copy of UserEngagement
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $UserEngagementCopyWith<UserEngagement> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserEngagementCopyWith<$Res> {
  factory $UserEngagementCopyWith(
          UserEngagement value, $Res Function(UserEngagement) then) =
      _$UserEngagementCopyWithImpl<$Res, UserEngagement>;
  @useResult
  $Res call(
      {dynamic hasReposted,
      dynamic hasRepostedWithComment,
      dynamic hasCommented});
}

/// @nodoc
class _$UserEngagementCopyWithImpl<$Res, $Val extends UserEngagement>
    implements $UserEngagementCopyWith<$Res> {
  _$UserEngagementCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of UserEngagement
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hasReposted = freezed,
    Object? hasRepostedWithComment = freezed,
    Object? hasCommented = freezed,
  }) {
    return _then(_value.copyWith(
      hasReposted: freezed == hasReposted
          ? _value.hasReposted
          : hasReposted // ignore: cast_nullable_to_non_nullable
              as dynamic,
      hasRepostedWithComment: freezed == hasRepostedWithComment
          ? _value.hasRepostedWithComment
          : hasRepostedWithComment // ignore: cast_nullable_to_non_nullable
              as dynamic,
      hasCommented: freezed == hasCommented
          ? _value.hasCommented
          : hasCommented // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$UserEngagementImplCopyWith<$Res>
    implements $UserEngagementCopyWith<$Res> {
  factory _$$UserEngagementImplCopyWith(_$UserEngagementImpl value,
          $Res Function(_$UserEngagementImpl) then) =
      __$$UserEngagementImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {dynamic hasReposted,
      dynamic hasRepostedWithComment,
      dynamic hasCommented});
}

/// @nodoc
class __$$UserEngagementImplCopyWithImpl<$Res>
    extends _$UserEngagementCopyWithImpl<$Res, _$UserEngagementImpl>
    implements _$$UserEngagementImplCopyWith<$Res> {
  __$$UserEngagementImplCopyWithImpl(
      _$UserEngagementImpl _value, $Res Function(_$UserEngagementImpl) _then)
      : super(_value, _then);

  /// Create a copy of UserEngagement
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hasReposted = freezed,
    Object? hasRepostedWithComment = freezed,
    Object? hasCommented = freezed,
  }) {
    return _then(_$UserEngagementImpl(
      hasReposted: freezed == hasReposted
          ? _value.hasReposted
          : hasReposted // ignore: cast_nullable_to_non_nullable
              as dynamic,
      hasRepostedWithComment: freezed == hasRepostedWithComment
          ? _value.hasRepostedWithComment
          : hasRepostedWithComment // ignore: cast_nullable_to_non_nullable
              as dynamic,
      hasCommented: freezed == hasCommented
          ? _value.hasCommented
          : hasCommented // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc

class _$UserEngagementImpl implements _UserEngagement {
  const _$UserEngagementImpl(
      {required this.hasReposted,
      required this.hasRepostedWithComment,
      required this.hasCommented});

  @override
  final dynamic hasReposted;
  @override
  final dynamic hasRepostedWithComment;
  @override
  final dynamic hasCommented;

  @override
  String toString() {
    return 'UserEngagement(hasReposted: $hasReposted, hasRepostedWithComment: $hasRepostedWithComment, hasCommented: $hasCommented)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserEngagementImpl &&
            const DeepCollectionEquality()
                .equals(other.hasReposted, hasReposted) &&
            const DeepCollectionEquality()
                .equals(other.hasRepostedWithComment, hasRepostedWithComment) &&
            const DeepCollectionEquality()
                .equals(other.hasCommented, hasCommented));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(hasReposted),
      const DeepCollectionEquality().hash(hasRepostedWithComment),
      const DeepCollectionEquality().hash(hasCommented));

  /// Create a copy of UserEngagement
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UserEngagementImplCopyWith<_$UserEngagementImpl> get copyWith =>
      __$$UserEngagementImplCopyWithImpl<_$UserEngagementImpl>(
          this, _$identity);
}

abstract class _UserEngagement implements UserEngagement {
  const factory _UserEngagement(
      {required final dynamic hasReposted,
      required final dynamic hasRepostedWithComment,
      required final dynamic hasCommented}) = _$UserEngagementImpl;

  @override
  dynamic get hasReposted;
  @override
  dynamic get hasRepostedWithComment;
  @override
  dynamic get hasCommented;

  /// Create a copy of UserEngagement
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UserEngagementImplCopyWith<_$UserEngagementImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PostEngagement {
  int get totalCommentCount => throw _privateConstructorUsedError;
  int get commentCount => throw _privateConstructorUsedError;
  int get views => throw _privateConstructorUsedError;
  List<Reaction> get reactions => throw _privateConstructorUsedError;

  /// Create a copy of PostEngagement
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PostEngagementCopyWith<PostEngagement> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PostEngagementCopyWith<$Res> {
  factory $PostEngagementCopyWith(
          PostEngagement value, $Res Function(PostEngagement) then) =
      _$PostEngagementCopyWithImpl<$Res, PostEngagement>;
  @useResult
  $Res call(
      {int totalCommentCount,
      int commentCount,
      int views,
      List<Reaction> reactions});
}

/// @nodoc
class _$PostEngagementCopyWithImpl<$Res, $Val extends PostEngagement>
    implements $PostEngagementCopyWith<$Res> {
  _$PostEngagementCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PostEngagement
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? totalCommentCount = null,
    Object? commentCount = null,
    Object? views = null,
    Object? reactions = null,
  }) {
    return _then(_value.copyWith(
      totalCommentCount: null == totalCommentCount
          ? _value.totalCommentCount
          : totalCommentCount // ignore: cast_nullable_to_non_nullable
              as int,
      commentCount: null == commentCount
          ? _value.commentCount
          : commentCount // ignore: cast_nullable_to_non_nullable
              as int,
      views: null == views
          ? _value.views
          : views // ignore: cast_nullable_to_non_nullable
              as int,
      reactions: null == reactions
          ? _value.reactions
          : reactions // ignore: cast_nullable_to_non_nullable
              as List<Reaction>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PostEngagementImplCopyWith<$Res>
    implements $PostEngagementCopyWith<$Res> {
  factory _$$PostEngagementImplCopyWith(_$PostEngagementImpl value,
          $Res Function(_$PostEngagementImpl) then) =
      __$$PostEngagementImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int totalCommentCount,
      int commentCount,
      int views,
      List<Reaction> reactions});
}

/// @nodoc
class __$$PostEngagementImplCopyWithImpl<$Res>
    extends _$PostEngagementCopyWithImpl<$Res, _$PostEngagementImpl>
    implements _$$PostEngagementImplCopyWith<$Res> {
  __$$PostEngagementImplCopyWithImpl(
      _$PostEngagementImpl _value, $Res Function(_$PostEngagementImpl) _then)
      : super(_value, _then);

  /// Create a copy of PostEngagement
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? totalCommentCount = null,
    Object? commentCount = null,
    Object? views = null,
    Object? reactions = null,
  }) {
    return _then(_$PostEngagementImpl(
      totalCommentCount: null == totalCommentCount
          ? _value.totalCommentCount
          : totalCommentCount // ignore: cast_nullable_to_non_nullable
              as int,
      commentCount: null == commentCount
          ? _value.commentCount
          : commentCount // ignore: cast_nullable_to_non_nullable
              as int,
      views: null == views
          ? _value.views
          : views // ignore: cast_nullable_to_non_nullable
              as int,
      reactions: null == reactions
          ? _value._reactions
          : reactions // ignore: cast_nullable_to_non_nullable
              as List<Reaction>,
    ));
  }
}

/// @nodoc

class _$PostEngagementImpl implements _PostEngagement {
  const _$PostEngagementImpl(
      {required this.totalCommentCount,
      required this.commentCount,
      required this.views,
      required final List<Reaction> reactions})
      : _reactions = reactions;

  @override
  final int totalCommentCount;
  @override
  final int commentCount;
  @override
  final int views;
  final List<Reaction> _reactions;
  @override
  List<Reaction> get reactions {
    if (_reactions is EqualUnmodifiableListView) return _reactions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_reactions);
  }

  @override
  String toString() {
    return 'PostEngagement(totalCommentCount: $totalCommentCount, commentCount: $commentCount, views: $views, reactions: $reactions)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PostEngagementImpl &&
            (identical(other.totalCommentCount, totalCommentCount) ||
                other.totalCommentCount == totalCommentCount) &&
            (identical(other.commentCount, commentCount) ||
                other.commentCount == commentCount) &&
            (identical(other.views, views) || other.views == views) &&
            const DeepCollectionEquality()
                .equals(other._reactions, _reactions));
  }

  @override
  int get hashCode => Object.hash(runtimeType, totalCommentCount, commentCount,
      views, const DeepCollectionEquality().hash(_reactions));

  /// Create a copy of PostEngagement
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PostEngagementImplCopyWith<_$PostEngagementImpl> get copyWith =>
      __$$PostEngagementImplCopyWithImpl<_$PostEngagementImpl>(
          this, _$identity);
}

abstract class _PostEngagement implements PostEngagement {
  const factory _PostEngagement(
      {required final int totalCommentCount,
      required final int commentCount,
      required final int views,
      required final List<Reaction> reactions}) = _$PostEngagementImpl;

  @override
  int get totalCommentCount;
  @override
  int get commentCount;
  @override
  int get views;
  @override
  List<Reaction> get reactions;

  /// Create a copy of PostEngagement
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PostEngagementImplCopyWith<_$PostEngagementImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Reaction {
  String get name => throw _privateConstructorUsedError;
  int get count => throw _privateConstructorUsedError;

  /// Create a copy of Reaction
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ReactionCopyWith<Reaction> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ReactionCopyWith<$Res> {
  factory $ReactionCopyWith(Reaction value, $Res Function(Reaction) then) =
      _$ReactionCopyWithImpl<$Res, Reaction>;
  @useResult
  $Res call({String name, int count});
}

/// @nodoc
class _$ReactionCopyWithImpl<$Res, $Val extends Reaction>
    implements $ReactionCopyWith<$Res> {
  _$ReactionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Reaction
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? count = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ReactionImplCopyWith<$Res>
    implements $ReactionCopyWith<$Res> {
  factory _$$ReactionImplCopyWith(
          _$ReactionImpl value, $Res Function(_$ReactionImpl) then) =
      __$$ReactionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, int count});
}

/// @nodoc
class __$$ReactionImplCopyWithImpl<$Res>
    extends _$ReactionCopyWithImpl<$Res, _$ReactionImpl>
    implements _$$ReactionImplCopyWith<$Res> {
  __$$ReactionImplCopyWithImpl(
      _$ReactionImpl _value, $Res Function(_$ReactionImpl) _then)
      : super(_value, _then);

  /// Create a copy of Reaction
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? count = null,
  }) {
    return _then(_$ReactionImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ReactionImpl implements _Reaction {
  const _$ReactionImpl({required this.name, required this.count});

  @override
  final String name;
  @override
  final int count;

  @override
  String toString() {
    return 'Reaction(name: $name, count: $count)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ReactionImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.count, count) || other.count == count));
  }

  @override
  int get hashCode => Object.hash(runtimeType, name, count);

  /// Create a copy of Reaction
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ReactionImplCopyWith<_$ReactionImpl> get copyWith =>
      __$$ReactionImplCopyWithImpl<_$ReactionImpl>(this, _$identity);
}

abstract class _Reaction implements Reaction {
  const factory _Reaction(
      {required final String name, required final int count}) = _$ReactionImpl;

  @override
  String get name;
  @override
  int get count;

  /// Create a copy of Reaction
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ReactionImplCopyWith<_$ReactionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SingleVideo {
  dynamic get url => throw _privateConstructorUsedError;
  int? get widthPx => throw _privateConstructorUsedError;
  int? get heightPx => throw _privateConstructorUsedError;
  dynamic get mimeType => throw _privateConstructorUsedError;
  int get duration => throw _privateConstructorUsedError;
  int? get lastPosition => throw _privateConstructorUsedError;
  VideoThumbnail get thumbnail => throw _privateConstructorUsedError;

  /// Create a copy of SingleVideo
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SingleVideoCopyWith<SingleVideo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SingleVideoCopyWith<$Res> {
  factory $SingleVideoCopyWith(
          SingleVideo value, $Res Function(SingleVideo) then) =
      _$SingleVideoCopyWithImpl<$Res, SingleVideo>;
  @useResult
  $Res call(
      {dynamic url,
      int? widthPx,
      int? heightPx,
      dynamic mimeType,
      int duration,
      int? lastPosition,
      VideoThumbnail thumbnail});

  $VideoThumbnailCopyWith<$Res> get thumbnail;
}

/// @nodoc
class _$SingleVideoCopyWithImpl<$Res, $Val extends SingleVideo>
    implements $SingleVideoCopyWith<$Res> {
  _$SingleVideoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SingleVideo
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = freezed,
    Object? widthPx = freezed,
    Object? heightPx = freezed,
    Object? mimeType = freezed,
    Object? duration = null,
    Object? lastPosition = freezed,
    Object? thumbnail = null,
  }) {
    return _then(_value.copyWith(
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as dynamic,
      widthPx: freezed == widthPx
          ? _value.widthPx
          : widthPx // ignore: cast_nullable_to_non_nullable
              as int?,
      heightPx: freezed == heightPx
          ? _value.heightPx
          : heightPx // ignore: cast_nullable_to_non_nullable
              as int?,
      mimeType: freezed == mimeType
          ? _value.mimeType
          : mimeType // ignore: cast_nullable_to_non_nullable
              as dynamic,
      duration: null == duration
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as int,
      lastPosition: freezed == lastPosition
          ? _value.lastPosition
          : lastPosition // ignore: cast_nullable_to_non_nullable
              as int?,
      thumbnail: null == thumbnail
          ? _value.thumbnail
          : thumbnail // ignore: cast_nullable_to_non_nullable
              as VideoThumbnail,
    ) as $Val);
  }

  /// Create a copy of SingleVideo
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $VideoThumbnailCopyWith<$Res> get thumbnail {
    return $VideoThumbnailCopyWith<$Res>(_value.thumbnail, (value) {
      return _then(_value.copyWith(thumbnail: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$SingleVideoImplCopyWith<$Res>
    implements $SingleVideoCopyWith<$Res> {
  factory _$$SingleVideoImplCopyWith(
          _$SingleVideoImpl value, $Res Function(_$SingleVideoImpl) then) =
      __$$SingleVideoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {dynamic url,
      int? widthPx,
      int? heightPx,
      dynamic mimeType,
      int duration,
      int? lastPosition,
      VideoThumbnail thumbnail});

  @override
  $VideoThumbnailCopyWith<$Res> get thumbnail;
}

/// @nodoc
class __$$SingleVideoImplCopyWithImpl<$Res>
    extends _$SingleVideoCopyWithImpl<$Res, _$SingleVideoImpl>
    implements _$$SingleVideoImplCopyWith<$Res> {
  __$$SingleVideoImplCopyWithImpl(
      _$SingleVideoImpl _value, $Res Function(_$SingleVideoImpl) _then)
      : super(_value, _then);

  /// Create a copy of SingleVideo
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = freezed,
    Object? widthPx = freezed,
    Object? heightPx = freezed,
    Object? mimeType = freezed,
    Object? duration = null,
    Object? lastPosition = freezed,
    Object? thumbnail = null,
  }) {
    return _then(_$SingleVideoImpl(
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as dynamic,
      widthPx: freezed == widthPx
          ? _value.widthPx
          : widthPx // ignore: cast_nullable_to_non_nullable
              as int?,
      heightPx: freezed == heightPx
          ? _value.heightPx
          : heightPx // ignore: cast_nullable_to_non_nullable
              as int?,
      mimeType: freezed == mimeType
          ? _value.mimeType
          : mimeType // ignore: cast_nullable_to_non_nullable
              as dynamic,
      duration: null == duration
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as int,
      lastPosition: freezed == lastPosition
          ? _value.lastPosition
          : lastPosition // ignore: cast_nullable_to_non_nullable
              as int?,
      thumbnail: null == thumbnail
          ? _value.thumbnail
          : thumbnail // ignore: cast_nullable_to_non_nullable
              as VideoThumbnail,
    ));
  }
}

/// @nodoc

class _$SingleVideoImpl implements _SingleVideo {
  const _$SingleVideoImpl(
      {required this.url,
      required this.widthPx,
      required this.heightPx,
      required this.mimeType,
      required this.duration,
      required this.lastPosition,
      required this.thumbnail});

  @override
  final dynamic url;
  @override
  final int? widthPx;
  @override
  final int? heightPx;
  @override
  final dynamic mimeType;
  @override
  final int duration;
  @override
  final int? lastPosition;
  @override
  final VideoThumbnail thumbnail;

  @override
  String toString() {
    return 'SingleVideo(url: $url, widthPx: $widthPx, heightPx: $heightPx, mimeType: $mimeType, duration: $duration, lastPosition: $lastPosition, thumbnail: $thumbnail)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SingleVideoImpl &&
            const DeepCollectionEquality().equals(other.url, url) &&
            (identical(other.widthPx, widthPx) || other.widthPx == widthPx) &&
            (identical(other.heightPx, heightPx) ||
                other.heightPx == heightPx) &&
            const DeepCollectionEquality().equals(other.mimeType, mimeType) &&
            (identical(other.duration, duration) ||
                other.duration == duration) &&
            (identical(other.lastPosition, lastPosition) ||
                other.lastPosition == lastPosition) &&
            (identical(other.thumbnail, thumbnail) ||
                other.thumbnail == thumbnail));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(url),
      widthPx,
      heightPx,
      const DeepCollectionEquality().hash(mimeType),
      duration,
      lastPosition,
      thumbnail);

  /// Create a copy of SingleVideo
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SingleVideoImplCopyWith<_$SingleVideoImpl> get copyWith =>
      __$$SingleVideoImplCopyWithImpl<_$SingleVideoImpl>(this, _$identity);
}

abstract class _SingleVideo implements SingleVideo {
  const factory _SingleVideo(
      {required final dynamic url,
      required final int? widthPx,
      required final int? heightPx,
      required final dynamic mimeType,
      required final int duration,
      required final int? lastPosition,
      required final VideoThumbnail thumbnail}) = _$SingleVideoImpl;

  @override
  dynamic get url;
  @override
  int? get widthPx;
  @override
  int? get heightPx;
  @override
  dynamic get mimeType;
  @override
  int get duration;
  @override
  int? get lastPosition;
  @override
  VideoThumbnail get thumbnail;

  /// Create a copy of SingleVideo
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SingleVideoImplCopyWith<_$SingleVideoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$VideoThumbnail {
  dynamic get url => throw _privateConstructorUsedError;
  int? get widthPx => throw _privateConstructorUsedError;
  int? get heightPx => throw _privateConstructorUsedError;
  dynamic get mimeType => throw _privateConstructorUsedError;

  /// Create a copy of VideoThumbnail
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $VideoThumbnailCopyWith<VideoThumbnail> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VideoThumbnailCopyWith<$Res> {
  factory $VideoThumbnailCopyWith(
          VideoThumbnail value, $Res Function(VideoThumbnail) then) =
      _$VideoThumbnailCopyWithImpl<$Res, VideoThumbnail>;
  @useResult
  $Res call({dynamic url, int? widthPx, int? heightPx, dynamic mimeType});
}

/// @nodoc
class _$VideoThumbnailCopyWithImpl<$Res, $Val extends VideoThumbnail>
    implements $VideoThumbnailCopyWith<$Res> {
  _$VideoThumbnailCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of VideoThumbnail
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = freezed,
    Object? widthPx = freezed,
    Object? heightPx = freezed,
    Object? mimeType = freezed,
  }) {
    return _then(_value.copyWith(
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as dynamic,
      widthPx: freezed == widthPx
          ? _value.widthPx
          : widthPx // ignore: cast_nullable_to_non_nullable
              as int?,
      heightPx: freezed == heightPx
          ? _value.heightPx
          : heightPx // ignore: cast_nullable_to_non_nullable
              as int?,
      mimeType: freezed == mimeType
          ? _value.mimeType
          : mimeType // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$VideoThumbnailImplCopyWith<$Res>
    implements $VideoThumbnailCopyWith<$Res> {
  factory _$$VideoThumbnailImplCopyWith(_$VideoThumbnailImpl value,
          $Res Function(_$VideoThumbnailImpl) then) =
      __$$VideoThumbnailImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({dynamic url, int? widthPx, int? heightPx, dynamic mimeType});
}

/// @nodoc
class __$$VideoThumbnailImplCopyWithImpl<$Res>
    extends _$VideoThumbnailCopyWithImpl<$Res, _$VideoThumbnailImpl>
    implements _$$VideoThumbnailImplCopyWith<$Res> {
  __$$VideoThumbnailImplCopyWithImpl(
      _$VideoThumbnailImpl _value, $Res Function(_$VideoThumbnailImpl) _then)
      : super(_value, _then);

  /// Create a copy of VideoThumbnail
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = freezed,
    Object? widthPx = freezed,
    Object? heightPx = freezed,
    Object? mimeType = freezed,
  }) {
    return _then(_$VideoThumbnailImpl(
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as dynamic,
      widthPx: freezed == widthPx
          ? _value.widthPx
          : widthPx // ignore: cast_nullable_to_non_nullable
              as int?,
      heightPx: freezed == heightPx
          ? _value.heightPx
          : heightPx // ignore: cast_nullable_to_non_nullable
              as int?,
      mimeType: freezed == mimeType
          ? _value.mimeType
          : mimeType // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc

class _$VideoThumbnailImpl implements _VideoThumbnail {
  const _$VideoThumbnailImpl(
      {required this.url,
      required this.widthPx,
      required this.heightPx,
      required this.mimeType});

  @override
  final dynamic url;
  @override
  final int? widthPx;
  @override
  final int? heightPx;
  @override
  final dynamic mimeType;

  @override
  String toString() {
    return 'VideoThumbnail(url: $url, widthPx: $widthPx, heightPx: $heightPx, mimeType: $mimeType)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VideoThumbnailImpl &&
            const DeepCollectionEquality().equals(other.url, url) &&
            (identical(other.widthPx, widthPx) || other.widthPx == widthPx) &&
            (identical(other.heightPx, heightPx) ||
                other.heightPx == heightPx) &&
            const DeepCollectionEquality().equals(other.mimeType, mimeType));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(url),
      widthPx,
      heightPx,
      const DeepCollectionEquality().hash(mimeType));

  /// Create a copy of VideoThumbnail
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$VideoThumbnailImplCopyWith<_$VideoThumbnailImpl> get copyWith =>
      __$$VideoThumbnailImplCopyWithImpl<_$VideoThumbnailImpl>(
          this, _$identity);
}

abstract class _VideoThumbnail implements VideoThumbnail {
  const factory _VideoThumbnail(
      {required final dynamic url,
      required final int? widthPx,
      required final int? heightPx,
      required final dynamic mimeType}) = _$VideoThumbnailImpl;

  @override
  dynamic get url;
  @override
  int? get widthPx;
  @override
  int? get heightPx;
  @override
  dynamic get mimeType;

  /// Create a copy of VideoThumbnail
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$VideoThumbnailImplCopyWith<_$VideoThumbnailImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
